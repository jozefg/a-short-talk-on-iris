\documentclass{amsart}
\usepackage{amsmath, amssymb}
\usepackage{mathpartir}
\usepackage{natbib}
\usepackage{iris}

\newcommand{\limplies}{\to}
\newcommand{\forces}{\Vdash}

\title{Iris, Briefly}
\author{Daniel Gratzer}
\date{\today}

\begin{document}
\maketitle

The purpose of this note is to briefly introduce those familiar with
some variant of concurrent separation
logic~\citep{OHearn:02,OHearn:07} to the Iris
logic~\citep{Jung:15,Jung:16,Krebbers:17,Jung:17}. Like O'Hearn's
logic, Iris presents a framework for reasoning about programs with
concurrency and shared state. Unlike Concurrent Separation Logic, Iris
is not a collection of inferences rules defining axiomitizing a
Hoare-triple-like judgment~\citep{Hoare:69}.

Iris comes from nearly 15 years after the first introduction of
concurrent separation logic and in that time there has been an
explosion of concurrent separation logics~\citep{Parkinson:10}. Each
new program or idiom has seemed to spawn a new concurrent separation
logic, more complicated than any that came before it, which allows the
verification of most of the previously possible programs and this new
one. This state of affairs was highly unsatisfying for a number of
reasons, chief among them being that there was no endpoint in
sight. None of these logics claimed to be a clean or complete solution
and the expectation was that in a years time the work put into this
logic must be redone in order to extend it to a new class of
programs. This constant churn also damaged the usability of each
logic, there was no point in creating tooling or any library of
verified programs in a logic that was to be obsoleted in 6 months.

Given this state of affairs, Iris is an attempt to provide a unified
foundation for a \emph{variety} of concurrent separation
logics. Rather than fixing a particular collection of rules and baking
in a few concurrency patterns Iris provides the tools needed to encode
these rules. This means that the formal definition of Iris makes no
mention of a particular form of concurrency, nor indeed a particular
programming language of any sort. There is no notion of Hoare triples
or weakest preconditions, let alone invariants or even really ghost
state. All of these notions are instead encoded which has crucially
left them available to change. Indeed, the central difference between
Iris when originally proposed~\citep{Jung:15} and the version
currently used~\citep{Jung:17} is that more and more of Iris has been
encoded rather than primitively given.

In this note we discuss the base system of Iris and how we can move
from the handful of modalities added to higher-order bunched
implication logic to a full blown separation logic. To finish, we
shall briefly discuss some of the surprising extensions made to Iris.

\section{The Base Logic of Iris}

It has long been folklore~\footnote{Listen, it's called folklore
  because I don't know who to cite for this observation} that
separation logic can been understood as an instance of bunched
implication logic. In this form, rather than having merely the usual
connectives of propositional logic, $\limplies$ and $\land$, two new
connectives are added: $\sep$ and $\wand$. The first of these new
connectives will be familiar to anyone who has studied separation
logic. In separation logic, we judge propositions to be true relative
to some heap and $P_1 \sep P_2$ is true of some heap $h$,
$h \forces P_1 \sep P_2$, precisely when the following holds.
\[
  \Exists h_1, h_2. h_1 \uplus h_2 = h
  \land h_1 \forces P_1
  \land h_2 \forces P_2
\]
Bunched implication logic generalizes this idea and abstracts it
away. Rather than dealing with propositions relative to a heap, a new
judgmental structure is introduced to explain $\sep$. Contexts switch
from being a list of proposition to a full tree, called bunches. They
are generated by the following grammar subject to some simple
algebraic rules.
\[
  \Gamma ::= \cdot \mid \Gamma; \Gamma \mid \Gamma, \Gamma
\]
Since contexts are now trees, it is more difficult to notate what it
means to appear in the middle of a context. Let $\Gamma(\Delta)$ mean
that $\Gamma$ is a tree a hole in it which we have filled with
$\Delta$. As is usual in a substructural logic, we understand $\land$
and $\limplies$ to internalize the $;$ in contexts. This is governed
by the usual rules
\[
  \inferrule{
    \Gamma_1 \vdash P_1 \\ \Gamma_2 \vdash P_2
  }{\Gamma_1; \Gamma_2 \vdash P_1 \land P_2}\qquad
  \inferrule{
    \Gamma(P_1; P_2) \vdash P_3
  }{\Gamma(P_1 \land P_2) \vdash P_3}
\]
\[
  \inferrule{
    \Gamma_1; P_1 \vdash P_2
  }{\Gamma \vdash P_1 \limplies P_2}\qquad
  \inferrule{
    \Gamma_1 \vdash P_1 \limplies P_2 \\ \Gamma_2 \vdash P_1
  }{\Gamma_1; \Gamma_2; \vdash P_3}
\]
These rules, ignoring the complications introduced by working with
bunches, are the usual rules. Indeed they are forced to be this way
semantically if we wish to preserve the usual relation between $\land$
and $\limplies$.
\[
  \mprset{fraction={===}}
  \inferrule{
    P_1 \vdash P_2 \limplies P_3
  }{P_1 \land P_2 \vdash P_3}
\]
Bunched implication logic also now seemlessly provides a proof-theory
for separating conjunction: $\sep$ internalizing $,$ in the same way
that $\land$ internalizes $;$.
\[
  \inferrule{
    \Gamma_1 \vdash P_1 \\ \Gamma_2 \vdash P_2
  }{\Gamma_1, \Gamma_2 \vdash P_1 \sep P_2}\qquad
  \inferrule{
    \Gamma(P_1, P_2) \vdash P_3
  }{\Gamma(P_1 \sep P_2) \vdash P_3}
\]
This new judgmental structure exposes a new connective though: the
analogue of $\limplies$ for separating conjunction. It is written
$\wand$ and pronounced \emph{(magic) wand}.
\[
  \inferrule{
    \Gamma_1 \vdash P_1 \\ \Gamma_2 \vdash P_2
  }{\Gamma_1, \Gamma_2 \vdash P_1 \sep P_2}\qquad
  \inferrule{
    \Gamma(P_1, P_2) \vdash P_3
  }{\Gamma(P_1 \sep P_2) \vdash P_3}
\]
With these four connectives we have the foundations of bunched
implication logic and with it, Iris. Let us now discuss the components
on top of propositional BI that Iris makes use of.

\subsection{Higher-Order Bunched Implication Logic}

\subsection{Integrating Ghost State Parametrically}

\subsection{Guardedness and L\"ob Induction}

\subsection{The Always Modality}

\section{The Model of Iris}

\section{Building a Concurrent Separation Logic}

\section{Applications}

\section{Conclusion}


\bibliographystyle{plainnat}
\bibliography{csl}{}
\end{document}
